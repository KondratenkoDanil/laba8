#include <iostream>

int main() {
    long x[11] = { 7, 23, 56, 33, 15, 11, 74, 3, 21, 8, 19 }; // Масив з 11 елементів

    __asm {
        lea ESI, x             // Завантажуємо адресу початку масиву в ESI
        mov ECX, 11            // Кількість елементів масиву (11)

        outer_loop:
        mov EDI, ESI       // Початковий елемент для пошуку максимуму
            mov EBX, ESI       // Найбільший елемент (припускаємо перший)
            mov EDX, ECX       // Лічильник внутрішнього циклу

            inner_loop :
        cmp[EDI], [EBX]   // Порівнюємо поточний елемент із максимальним
            jle skip_update    // Якщо [EDI] <= [EBX], переходимо далі
            mov EBX, EDI       // Оновлюємо адресу максимального елемента

            skip_update :
        add EDI, 4         // Переходимо до наступного елемента
            dec EDX            // Зменшуємо лічильник внутрішнього циклу
            jnz inner_loop     // Повторюємо, доки не закінчиться цикл

            cmp EBX, ESI           // Порівнюємо адресу максимуму з поточною
            je no_swap             // Якщо вони збігаються, обмін не потрібен

            // Обмін елементами: x[ESI] <-> x[EBX]
            mov EAX, [ESI]         // Завантажуємо x[ESI] у EAX
            mov EDX, [EBX]         // Завантажуємо x[EBX] у EDX
            mov[ESI], EDX         // x[ESI] = x[EBX]
            mov[EBX], EAX         // x[EBX] = EAX

            no_swap :
        add ESI, 4         // Переходимо до наступного елемента
            dec ECX            // Зменшуємо кількість елементів у зовнішньому циклі
            cmp ECX, 1         // Перевіряємо, чи залишився один елемент
            jne outer_loop     // Повторюємо, якщо більше одного елемента
    }

    // Виведення відсортованого масиву
    std::cout << "Відсортований масив за спаданням: ";
    for (int i = 0; i < 11; i++) {
        std::cout << x[i] << " ";
    }
    std::cout << std::endl;

    return 0;
}
